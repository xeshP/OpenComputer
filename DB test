component = require("component")
serialize = require("serialization")
dbcount = 0
--hashtable = {}  ---tab["label"] = "hash"t

readnserial = function(filename)
    filer=io.open(filename,"r")
    cont=filer:read("*all")
    tabsi = serialize.unserialize(cont)
    filer:close()
    return tabsi
end

dbtable = readnserial("dblist.txt")
--if hashtable == nil then hashtable = {} end

storeto = function(label)
    dbhashcount = tonumber(readnserial("dbhashcount.txt"))
    print(dbhashcount)
    hashtable = readnserial("dbhash.txt")
    
    if dbhashcount < 81 then
        num = dbhashcount+1
        basenum = 1
    else
        if (dbhashcount/81) >= 1 then
            basenum = (math.ceil((dbhashcount+1)/81)) ---- 2 3 4 5 oder mehr
            num = (dbhashcount-((basenum-1)*81)+1)
        end
end
    print(basenum.."  databasenum")
    print(num.."  database numslot")
    databasenum = "database"..tostring(basenum)
    if label == "Mushroom" then
        if namesave == "minecraft:red_flower" then
            namesave = "minecraft:red_mushroom"
        end
        ME.store({name = namesave}, dbtable[databasenum], num)
        hashtosave = "exception:"..tostring(num)
        save("red_mushroom", hashtosave, "dbhash.txt")
    else
        ME.store({label = label}, dbtable[databasenum], num)
        hashtosave = component.proxy(dbtable[databasenum]).computeHash(num)
        save(label, hashtosave, "dbhash.txt")
    end
    
end


save = function(label, hashslot, filename)
    local data = readnserial("dbhash.txt")
    data[label] = hashslot
    local f=io.open(filename,"w")
    f:write(serialize.serialize(data))
    f:close()
    local f=io.open("dbhashcount.txt", "w")
    dbhashcount = dbhashcount+1
    f:write(tostring(dbhashcount))
    f:close()
end

cleardb = function(address)
    for r = 1,81 do
        component.proxy(address).clear(r)
    end
end


ME = component.me_interface

items = ME.getItemsInNetwork()
for k,v in pairs(items) do
    if type(v) == "table" then
        storeto(v.label)
        namesave = v.name
    end
end



